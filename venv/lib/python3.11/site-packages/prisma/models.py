# -*- coding: utf-8 -*-
# code generated by Prisma. DO NOT EDIT.
# pyright: reportUnusedImport=false
# fmt: off

# global imports for type checking
from builtins import bool as _bool
from builtins import int as _int
from builtins import float as _float
from builtins import str as _str
import sys
import decimal
import datetime
from typing import (
    TYPE_CHECKING,
    Optional,
    Iterable,
    Iterator,
    Sequence,
    Callable,
    ClassVar,
    NoReturn,
    TypeVar,
    Generic,
    Mapping,
    Tuple,
    Union,
    List,
    Dict,
    Type,
    Any,
    Set,
    overload,
    cast,
)
from typing_extensions import TypedDict, Literal


LiteralString = str
# -- template models.py.jinja --
import os
import logging
import inspect
import warnings
from collections import OrderedDict

from pydantic import BaseModel, Field

from . import types, enums, errors, fields, bases
from ._types import FuncType
from ._compat import model_rebuild, field_validator
from .builder import serialize_base64
from .generator import partial_models_ctx, PartialModelField


log: logging.Logger = logging.getLogger(__name__)
_created_partial_types: Set[str] = set()

class CEJ_Expedientes(bases.BaseCEJ_Expedientes):
    """Represents a CEJ_Expedientes record"""

    idExpediente: _int
    expedientePJ: _str
    cuadernos: _int
    actuaciones: _int
    created_at: datetime.datetime
    updated_at: datetime.datetime
    juzgado: Optional[_str] = None
    partes: Optional[_str] = None
    activo: Optional[_str] = None
    archivo: Optional[_str] = None
    usuarios: Optional[List['models.CEJ_ExpedientesUsuarios']] = None
    procesos: Optional[List['models.CEJ_ProcesoScrapingExpedientes']] = None
    detalleactuaciones: Optional[List['models.CEJ_ExpedientesActuaciones']] = None

    # take *args and **kwargs so that other metaclasses can define arguments
    def __init_subclass__(
        cls,
        *args: Any,
        warn_subclass: Optional[bool] = None,
        **kwargs: Any,
    ) -> None:
        super().__init_subclass__()
        if warn_subclass is not None:
            warnings.warn(
                'The `warn_subclass` argument is deprecated as it is no longer necessary and will be removed in the next release',
                DeprecationWarning,
                stacklevel=3,
            )


    @staticmethod
    def create_partial(
        name: str,
        include: Optional[Iterable['types.CEJ_ExpedientesKeys']] = None,
        exclude: Optional[Iterable['types.CEJ_ExpedientesKeys']] = None,
        required: Optional[Iterable['types.CEJ_ExpedientesKeys']] = None,
        optional: Optional[Iterable['types.CEJ_ExpedientesKeys']] = None,
        relations: Optional[Mapping['types.CEJ_ExpedientesRelationalFieldKeys', str]] = None,
        exclude_relational_fields: bool = False,
    ) -> None:
        if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
            raise RuntimeError(
                'Attempted to create a partial type outside of client generation.'
            )

        if name in _created_partial_types:
            raise ValueError(f'Partial type "{name}" has already been created.')

        if include is not None:
            if exclude is not None:
                raise TypeError('Exclude and include are mutually exclusive.')
            if exclude_relational_fields is True:
                raise TypeError('Include and exclude_relational_fields=True are mutually exclusive.')

        if required and optional:
            shared = set(required) & set(optional)
            if shared:
                raise ValueError(f'Cannot make the same field(s) required and optional {shared}')

        if exclude_relational_fields and relations:
            raise ValueError(
                'exclude_relational_fields and relations are mutually exclusive'
            )

        fields: Dict['types.CEJ_ExpedientesKeys', PartialModelField] = OrderedDict()

        try:
            if include:
                for field in include:
                    fields[field] = _CEJ_Expedientes_fields[field].copy()
            elif exclude:
                for field in exclude:
                    if field not in _CEJ_Expedientes_fields:
                        raise KeyError(field)

                fields = {
                    key: data.copy()
                    for key, data in _CEJ_Expedientes_fields.items()
                    if key not in exclude
                }
            else:
                fields = {
                    key: data.copy()
                    for key, data in _CEJ_Expedientes_fields.items()
                }

            if required:
                for field in required:
                    fields[field]['optional'] = False

            if optional:
                for field in optional:
                    fields[field]['optional'] = True

            if exclude_relational_fields:
                fields = {
                    key: data
                    for key, data in fields.items()
                    if key not in _CEJ_Expedientes_relational_fields
                }

            if relations:
                for field, type_ in relations.items():
                    if field not in _CEJ_Expedientes_relational_fields:
                        raise errors.UnknownRelationalFieldError('CEJ_Expedientes', field)

                    # TODO: this method of validating types is not ideal
                    # as it means we cannot two create partial types that
                    # reference each other
                    if type_ not in _created_partial_types:
                        raise ValueError(
                            f'Unknown partial type: "{type_}". '
                            f'Did you remember to generate the {type_} type before this one?'
                        )

                    # TODO: support non prisma.partials models
                    info = fields[field]
                    if info['is_list']:
                        info['type'] = f'List[\'partials.{type_}\']'
                    else:
                        info['type'] = f'\'partials.{type_}\''
        except KeyError as exc:
            raise ValueError(
                f'{exc.args[0]} is not a valid CEJ_Expedientes / {name} field.'
            ) from None

        models = partial_models_ctx.get()
        models.append(
            {
                'name': name,
                'fields': cast(Mapping[str, PartialModelField], fields),
                'from_model': 'CEJ_Expedientes',
            }
        )
        _created_partial_types.add(name)


class CEJ_ExpedientesUsuarios(bases.BaseCEJ_ExpedientesUsuarios):
    """Represents a CEJ_ExpedientesUsuarios record"""

    id: _int
    usuario: _str
    Expedientes: Optional['models.CEJ_Expedientes'] = None
    IdExpediente: Optional[_int] = None

    # take *args and **kwargs so that other metaclasses can define arguments
    def __init_subclass__(
        cls,
        *args: Any,
        warn_subclass: Optional[bool] = None,
        **kwargs: Any,
    ) -> None:
        super().__init_subclass__()
        if warn_subclass is not None:
            warnings.warn(
                'The `warn_subclass` argument is deprecated as it is no longer necessary and will be removed in the next release',
                DeprecationWarning,
                stacklevel=3,
            )


    @staticmethod
    def create_partial(
        name: str,
        include: Optional[Iterable['types.CEJ_ExpedientesUsuariosKeys']] = None,
        exclude: Optional[Iterable['types.CEJ_ExpedientesUsuariosKeys']] = None,
        required: Optional[Iterable['types.CEJ_ExpedientesUsuariosKeys']] = None,
        optional: Optional[Iterable['types.CEJ_ExpedientesUsuariosKeys']] = None,
        relations: Optional[Mapping['types.CEJ_ExpedientesUsuariosRelationalFieldKeys', str]] = None,
        exclude_relational_fields: bool = False,
    ) -> None:
        if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
            raise RuntimeError(
                'Attempted to create a partial type outside of client generation.'
            )

        if name in _created_partial_types:
            raise ValueError(f'Partial type "{name}" has already been created.')

        if include is not None:
            if exclude is not None:
                raise TypeError('Exclude and include are mutually exclusive.')
            if exclude_relational_fields is True:
                raise TypeError('Include and exclude_relational_fields=True are mutually exclusive.')

        if required and optional:
            shared = set(required) & set(optional)
            if shared:
                raise ValueError(f'Cannot make the same field(s) required and optional {shared}')

        if exclude_relational_fields and relations:
            raise ValueError(
                'exclude_relational_fields and relations are mutually exclusive'
            )

        fields: Dict['types.CEJ_ExpedientesUsuariosKeys', PartialModelField] = OrderedDict()

        try:
            if include:
                for field in include:
                    fields[field] = _CEJ_ExpedientesUsuarios_fields[field].copy()
            elif exclude:
                for field in exclude:
                    if field not in _CEJ_ExpedientesUsuarios_fields:
                        raise KeyError(field)

                fields = {
                    key: data.copy()
                    for key, data in _CEJ_ExpedientesUsuarios_fields.items()
                    if key not in exclude
                }
            else:
                fields = {
                    key: data.copy()
                    for key, data in _CEJ_ExpedientesUsuarios_fields.items()
                }

            if required:
                for field in required:
                    fields[field]['optional'] = False

            if optional:
                for field in optional:
                    fields[field]['optional'] = True

            if exclude_relational_fields:
                fields = {
                    key: data
                    for key, data in fields.items()
                    if key not in _CEJ_ExpedientesUsuarios_relational_fields
                }

            if relations:
                for field, type_ in relations.items():
                    if field not in _CEJ_ExpedientesUsuarios_relational_fields:
                        raise errors.UnknownRelationalFieldError('CEJ_ExpedientesUsuarios', field)

                    # TODO: this method of validating types is not ideal
                    # as it means we cannot two create partial types that
                    # reference each other
                    if type_ not in _created_partial_types:
                        raise ValueError(
                            f'Unknown partial type: "{type_}". '
                            f'Did you remember to generate the {type_} type before this one?'
                        )

                    # TODO: support non prisma.partials models
                    info = fields[field]
                    if info['is_list']:
                        info['type'] = f'List[\'partials.{type_}\']'
                    else:
                        info['type'] = f'\'partials.{type_}\''
        except KeyError as exc:
            raise ValueError(
                f'{exc.args[0]} is not a valid CEJ_ExpedientesUsuarios / {name} field.'
            ) from None

        models = partial_models_ctx.get()
        models.append(
            {
                'name': name,
                'fields': cast(Mapping[str, PartialModelField], fields),
                'from_model': 'CEJ_ExpedientesUsuarios',
            }
        )
        _created_partial_types.add(name)


class CEJ_ExpedientesActuaciones(bases.BaseCEJ_ExpedientesActuaciones):
    """Represents a CEJ_ExpedientesActuaciones record"""

    id: _int
    idExpediente: Optional[_int] = None
    idActuacion: _str
    fecha: datetime.datetime
    resolucion: Optional[_str] = None
    tiponotificacion: Optional[_str] = None
    acto: Optional[_str] = None
    fojas: Optional[_str] = None
    proveido: Optional[datetime.datetime] = None
    sumilla: Optional[_str] = None
    descripcion_usr: Optional[_str] = None
    resolucion_archivo: Optional[_str] = None
    Expedientes: Optional['models.CEJ_Expedientes'] = None
    created_at: datetime.datetime
    updated_at: datetime.datetime
    idProcesoUltimo: Optional[_int] = None

    # take *args and **kwargs so that other metaclasses can define arguments
    def __init_subclass__(
        cls,
        *args: Any,
        warn_subclass: Optional[bool] = None,
        **kwargs: Any,
    ) -> None:
        super().__init_subclass__()
        if warn_subclass is not None:
            warnings.warn(
                'The `warn_subclass` argument is deprecated as it is no longer necessary and will be removed in the next release',
                DeprecationWarning,
                stacklevel=3,
            )


    @staticmethod
    def create_partial(
        name: str,
        include: Optional[Iterable['types.CEJ_ExpedientesActuacionesKeys']] = None,
        exclude: Optional[Iterable['types.CEJ_ExpedientesActuacionesKeys']] = None,
        required: Optional[Iterable['types.CEJ_ExpedientesActuacionesKeys']] = None,
        optional: Optional[Iterable['types.CEJ_ExpedientesActuacionesKeys']] = None,
        relations: Optional[Mapping['types.CEJ_ExpedientesActuacionesRelationalFieldKeys', str]] = None,
        exclude_relational_fields: bool = False,
    ) -> None:
        if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
            raise RuntimeError(
                'Attempted to create a partial type outside of client generation.'
            )

        if name in _created_partial_types:
            raise ValueError(f'Partial type "{name}" has already been created.')

        if include is not None:
            if exclude is not None:
                raise TypeError('Exclude and include are mutually exclusive.')
            if exclude_relational_fields is True:
                raise TypeError('Include and exclude_relational_fields=True are mutually exclusive.')

        if required and optional:
            shared = set(required) & set(optional)
            if shared:
                raise ValueError(f'Cannot make the same field(s) required and optional {shared}')

        if exclude_relational_fields and relations:
            raise ValueError(
                'exclude_relational_fields and relations are mutually exclusive'
            )

        fields: Dict['types.CEJ_ExpedientesActuacionesKeys', PartialModelField] = OrderedDict()

        try:
            if include:
                for field in include:
                    fields[field] = _CEJ_ExpedientesActuaciones_fields[field].copy()
            elif exclude:
                for field in exclude:
                    if field not in _CEJ_ExpedientesActuaciones_fields:
                        raise KeyError(field)

                fields = {
                    key: data.copy()
                    for key, data in _CEJ_ExpedientesActuaciones_fields.items()
                    if key not in exclude
                }
            else:
                fields = {
                    key: data.copy()
                    for key, data in _CEJ_ExpedientesActuaciones_fields.items()
                }

            if required:
                for field in required:
                    fields[field]['optional'] = False

            if optional:
                for field in optional:
                    fields[field]['optional'] = True

            if exclude_relational_fields:
                fields = {
                    key: data
                    for key, data in fields.items()
                    if key not in _CEJ_ExpedientesActuaciones_relational_fields
                }

            if relations:
                for field, type_ in relations.items():
                    if field not in _CEJ_ExpedientesActuaciones_relational_fields:
                        raise errors.UnknownRelationalFieldError('CEJ_ExpedientesActuaciones', field)

                    # TODO: this method of validating types is not ideal
                    # as it means we cannot two create partial types that
                    # reference each other
                    if type_ not in _created_partial_types:
                        raise ValueError(
                            f'Unknown partial type: "{type_}". '
                            f'Did you remember to generate the {type_} type before this one?'
                        )

                    # TODO: support non prisma.partials models
                    info = fields[field]
                    if info['is_list']:
                        info['type'] = f'List[\'partials.{type_}\']'
                    else:
                        info['type'] = f'\'partials.{type_}\''
        except KeyError as exc:
            raise ValueError(
                f'{exc.args[0]} is not a valid CEJ_ExpedientesActuaciones / {name} field.'
            ) from None

        models = partial_models_ctx.get()
        models.append(
            {
                'name': name,
                'fields': cast(Mapping[str, PartialModelField], fields),
                'from_model': 'CEJ_ExpedientesActuaciones',
            }
        )
        _created_partial_types.add(name)


class CEJ_ProcesoScraping(bases.BaseCEJ_ProcesoScraping):
    """Represents a CEJ_ProcesoScraping record"""

    idProceso: _int
    created_at: datetime.datetime
    portalURL: _str
    concluido: _int
    totalExpedientes: _int
    updated_at: Optional[datetime.datetime] = None
    ProcesosExpedientes: Optional[List['models.CEJ_ProcesoScrapingExpedientes']] = None

    # take *args and **kwargs so that other metaclasses can define arguments
    def __init_subclass__(
        cls,
        *args: Any,
        warn_subclass: Optional[bool] = None,
        **kwargs: Any,
    ) -> None:
        super().__init_subclass__()
        if warn_subclass is not None:
            warnings.warn(
                'The `warn_subclass` argument is deprecated as it is no longer necessary and will be removed in the next release',
                DeprecationWarning,
                stacklevel=3,
            )


    @staticmethod
    def create_partial(
        name: str,
        include: Optional[Iterable['types.CEJ_ProcesoScrapingKeys']] = None,
        exclude: Optional[Iterable['types.CEJ_ProcesoScrapingKeys']] = None,
        required: Optional[Iterable['types.CEJ_ProcesoScrapingKeys']] = None,
        optional: Optional[Iterable['types.CEJ_ProcesoScrapingKeys']] = None,
        relations: Optional[Mapping['types.CEJ_ProcesoScrapingRelationalFieldKeys', str]] = None,
        exclude_relational_fields: bool = False,
    ) -> None:
        if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
            raise RuntimeError(
                'Attempted to create a partial type outside of client generation.'
            )

        if name in _created_partial_types:
            raise ValueError(f'Partial type "{name}" has already been created.')

        if include is not None:
            if exclude is not None:
                raise TypeError('Exclude and include are mutually exclusive.')
            if exclude_relational_fields is True:
                raise TypeError('Include and exclude_relational_fields=True are mutually exclusive.')

        if required and optional:
            shared = set(required) & set(optional)
            if shared:
                raise ValueError(f'Cannot make the same field(s) required and optional {shared}')

        if exclude_relational_fields and relations:
            raise ValueError(
                'exclude_relational_fields and relations are mutually exclusive'
            )

        fields: Dict['types.CEJ_ProcesoScrapingKeys', PartialModelField] = OrderedDict()

        try:
            if include:
                for field in include:
                    fields[field] = _CEJ_ProcesoScraping_fields[field].copy()
            elif exclude:
                for field in exclude:
                    if field not in _CEJ_ProcesoScraping_fields:
                        raise KeyError(field)

                fields = {
                    key: data.copy()
                    for key, data in _CEJ_ProcesoScraping_fields.items()
                    if key not in exclude
                }
            else:
                fields = {
                    key: data.copy()
                    for key, data in _CEJ_ProcesoScraping_fields.items()
                }

            if required:
                for field in required:
                    fields[field]['optional'] = False

            if optional:
                for field in optional:
                    fields[field]['optional'] = True

            if exclude_relational_fields:
                fields = {
                    key: data
                    for key, data in fields.items()
                    if key not in _CEJ_ProcesoScraping_relational_fields
                }

            if relations:
                for field, type_ in relations.items():
                    if field not in _CEJ_ProcesoScraping_relational_fields:
                        raise errors.UnknownRelationalFieldError('CEJ_ProcesoScraping', field)

                    # TODO: this method of validating types is not ideal
                    # as it means we cannot two create partial types that
                    # reference each other
                    if type_ not in _created_partial_types:
                        raise ValueError(
                            f'Unknown partial type: "{type_}". '
                            f'Did you remember to generate the {type_} type before this one?'
                        )

                    # TODO: support non prisma.partials models
                    info = fields[field]
                    if info['is_list']:
                        info['type'] = f'List[\'partials.{type_}\']'
                    else:
                        info['type'] = f'\'partials.{type_}\''
        except KeyError as exc:
            raise ValueError(
                f'{exc.args[0]} is not a valid CEJ_ProcesoScraping / {name} field.'
            ) from None

        models = partial_models_ctx.get()
        models.append(
            {
                'name': name,
                'fields': cast(Mapping[str, PartialModelField], fields),
                'from_model': 'CEJ_ProcesoScraping',
            }
        )
        _created_partial_types.add(name)


class CEJ_ProcesoScrapingExpedientes(bases.BaseCEJ_ProcesoScrapingExpedientes):
    """Represents a CEJ_ProcesoScrapingExpedientes record"""

    id: _int
    ProcesoScraping: Optional['models.CEJ_ProcesoScraping'] = None
    idProceso: Optional[_int] = None
    Expedientes: Optional['models.CEJ_Expedientes'] = None
    idExpediente: Optional[_int] = None
    totalCuadernos: _int
    totalActuaciones: _int
    error: Optional[_str] = None
    created_at: Optional[datetime.datetime] = None

    # take *args and **kwargs so that other metaclasses can define arguments
    def __init_subclass__(
        cls,
        *args: Any,
        warn_subclass: Optional[bool] = None,
        **kwargs: Any,
    ) -> None:
        super().__init_subclass__()
        if warn_subclass is not None:
            warnings.warn(
                'The `warn_subclass` argument is deprecated as it is no longer necessary and will be removed in the next release',
                DeprecationWarning,
                stacklevel=3,
            )


    @staticmethod
    def create_partial(
        name: str,
        include: Optional[Iterable['types.CEJ_ProcesoScrapingExpedientesKeys']] = None,
        exclude: Optional[Iterable['types.CEJ_ProcesoScrapingExpedientesKeys']] = None,
        required: Optional[Iterable['types.CEJ_ProcesoScrapingExpedientesKeys']] = None,
        optional: Optional[Iterable['types.CEJ_ProcesoScrapingExpedientesKeys']] = None,
        relations: Optional[Mapping['types.CEJ_ProcesoScrapingExpedientesRelationalFieldKeys', str]] = None,
        exclude_relational_fields: bool = False,
    ) -> None:
        if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
            raise RuntimeError(
                'Attempted to create a partial type outside of client generation.'
            )

        if name in _created_partial_types:
            raise ValueError(f'Partial type "{name}" has already been created.')

        if include is not None:
            if exclude is not None:
                raise TypeError('Exclude and include are mutually exclusive.')
            if exclude_relational_fields is True:
                raise TypeError('Include and exclude_relational_fields=True are mutually exclusive.')

        if required and optional:
            shared = set(required) & set(optional)
            if shared:
                raise ValueError(f'Cannot make the same field(s) required and optional {shared}')

        if exclude_relational_fields and relations:
            raise ValueError(
                'exclude_relational_fields and relations are mutually exclusive'
            )

        fields: Dict['types.CEJ_ProcesoScrapingExpedientesKeys', PartialModelField] = OrderedDict()

        try:
            if include:
                for field in include:
                    fields[field] = _CEJ_ProcesoScrapingExpedientes_fields[field].copy()
            elif exclude:
                for field in exclude:
                    if field not in _CEJ_ProcesoScrapingExpedientes_fields:
                        raise KeyError(field)

                fields = {
                    key: data.copy()
                    for key, data in _CEJ_ProcesoScrapingExpedientes_fields.items()
                    if key not in exclude
                }
            else:
                fields = {
                    key: data.copy()
                    for key, data in _CEJ_ProcesoScrapingExpedientes_fields.items()
                }

            if required:
                for field in required:
                    fields[field]['optional'] = False

            if optional:
                for field in optional:
                    fields[field]['optional'] = True

            if exclude_relational_fields:
                fields = {
                    key: data
                    for key, data in fields.items()
                    if key not in _CEJ_ProcesoScrapingExpedientes_relational_fields
                }

            if relations:
                for field, type_ in relations.items():
                    if field not in _CEJ_ProcesoScrapingExpedientes_relational_fields:
                        raise errors.UnknownRelationalFieldError('CEJ_ProcesoScrapingExpedientes', field)

                    # TODO: this method of validating types is not ideal
                    # as it means we cannot two create partial types that
                    # reference each other
                    if type_ not in _created_partial_types:
                        raise ValueError(
                            f'Unknown partial type: "{type_}". '
                            f'Did you remember to generate the {type_} type before this one?'
                        )

                    # TODO: support non prisma.partials models
                    info = fields[field]
                    if info['is_list']:
                        info['type'] = f'List[\'partials.{type_}\']'
                    else:
                        info['type'] = f'\'partials.{type_}\''
        except KeyError as exc:
            raise ValueError(
                f'{exc.args[0]} is not a valid CEJ_ProcesoScrapingExpedientes / {name} field.'
            ) from None

        models = partial_models_ctx.get()
        models.append(
            {
                'name': name,
                'fields': cast(Mapping[str, PartialModelField], fields),
                'from_model': 'CEJ_ProcesoScrapingExpedientes',
            }
        )
        _created_partial_types.add(name)



_CEJ_Expedientes_relational_fields: Set[str] = {
        'usuarios',
        'procesos',
        'detalleactuaciones',
    }
_CEJ_Expedientes_fields: Dict['types.CEJ_ExpedientesKeys', PartialModelField] = OrderedDict(
    [
        ('idExpediente', {
            'name': 'idExpediente',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('expedientePJ', {
            'name': 'expedientePJ',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('cuadernos', {
            'name': 'cuadernos',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('actuaciones', {
            'name': 'actuaciones',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('created_at', {
            'name': 'created_at',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('updated_at', {
            'name': 'updated_at',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('juzgado', {
            'name': 'juzgado',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('partes', {
            'name': 'partes',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('activo', {
            'name': 'activo',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('archivo', {
            'name': 'archivo',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('usuarios', {
            'name': 'usuarios',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.CEJ_ExpedientesUsuarios\']',
            'is_relational': True,
            'documentation': None,
        }),
        ('procesos', {
            'name': 'procesos',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.CEJ_ProcesoScrapingExpedientes\']',
            'is_relational': True,
            'documentation': None,
        }),
        ('detalleactuaciones', {
            'name': 'detalleactuaciones',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.CEJ_ExpedientesActuaciones\']',
            'is_relational': True,
            'documentation': None,
        }),
    ],
)

_CEJ_ExpedientesUsuarios_relational_fields: Set[str] = {
        'Expedientes',
    }
_CEJ_ExpedientesUsuarios_fields: Dict['types.CEJ_ExpedientesUsuariosKeys', PartialModelField] = OrderedDict(
    [
        ('id', {
            'name': 'id',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('usuario', {
            'name': 'usuario',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('Expedientes', {
            'name': 'Expedientes',
            'is_list': False,
            'optional': True,
            'type': 'models.CEJ_Expedientes',
            'is_relational': True,
            'documentation': None,
        }),
        ('IdExpediente', {
            'name': 'IdExpediente',
            'is_list': False,
            'optional': True,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
    ],
)

_CEJ_ExpedientesActuaciones_relational_fields: Set[str] = {
        'Expedientes',
    }
_CEJ_ExpedientesActuaciones_fields: Dict['types.CEJ_ExpedientesActuacionesKeys', PartialModelField] = OrderedDict(
    [
        ('id', {
            'name': 'id',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('idExpediente', {
            'name': 'idExpediente',
            'is_list': False,
            'optional': True,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('idActuacion', {
            'name': 'idActuacion',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('fecha', {
            'name': 'fecha',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('resolucion', {
            'name': 'resolucion',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('tiponotificacion', {
            'name': 'tiponotificacion',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('acto', {
            'name': 'acto',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('fojas', {
            'name': 'fojas',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('proveido', {
            'name': 'proveido',
            'is_list': False,
            'optional': True,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('sumilla', {
            'name': 'sumilla',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('descripcion_usr', {
            'name': 'descripcion_usr',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('resolucion_archivo', {
            'name': 'resolucion_archivo',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('Expedientes', {
            'name': 'Expedientes',
            'is_list': False,
            'optional': True,
            'type': 'models.CEJ_Expedientes',
            'is_relational': True,
            'documentation': None,
        }),
        ('created_at', {
            'name': 'created_at',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('updated_at', {
            'name': 'updated_at',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('idProcesoUltimo', {
            'name': 'idProcesoUltimo',
            'is_list': False,
            'optional': True,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
    ],
)

_CEJ_ProcesoScraping_relational_fields: Set[str] = {
        'ProcesosExpedientes',
    }
_CEJ_ProcesoScraping_fields: Dict['types.CEJ_ProcesoScrapingKeys', PartialModelField] = OrderedDict(
    [
        ('idProceso', {
            'name': 'idProceso',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('created_at', {
            'name': 'created_at',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('portalURL', {
            'name': 'portalURL',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('concluido', {
            'name': 'concluido',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('totalExpedientes', {
            'name': 'totalExpedientes',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('updated_at', {
            'name': 'updated_at',
            'is_list': False,
            'optional': True,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('ProcesosExpedientes', {
            'name': 'ProcesosExpedientes',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.CEJ_ProcesoScrapingExpedientes\']',
            'is_relational': True,
            'documentation': None,
        }),
    ],
)

_CEJ_ProcesoScrapingExpedientes_relational_fields: Set[str] = {
        'ProcesoScraping',
        'Expedientes',
    }
_CEJ_ProcesoScrapingExpedientes_fields: Dict['types.CEJ_ProcesoScrapingExpedientesKeys', PartialModelField] = OrderedDict(
    [
        ('id', {
            'name': 'id',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('ProcesoScraping', {
            'name': 'ProcesoScraping',
            'is_list': False,
            'optional': True,
            'type': 'models.CEJ_ProcesoScraping',
            'is_relational': True,
            'documentation': None,
        }),
        ('idProceso', {
            'name': 'idProceso',
            'is_list': False,
            'optional': True,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('Expedientes', {
            'name': 'Expedientes',
            'is_list': False,
            'optional': True,
            'type': 'models.CEJ_Expedientes',
            'is_relational': True,
            'documentation': None,
        }),
        ('idExpediente', {
            'name': 'idExpediente',
            'is_list': False,
            'optional': True,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('totalCuadernos', {
            'name': 'totalCuadernos',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('totalActuaciones', {
            'name': 'totalActuaciones',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('error', {
            'name': 'error',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('created_at', {
            'name': 'created_at',
            'is_list': False,
            'optional': True,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
    ],
)



# we have to import ourselves as relation types are namespaced to models
# e.g. models.Post
from . import models, actions

# required to support relationships between models
model_rebuild(CEJ_Expedientes)
model_rebuild(CEJ_ExpedientesUsuarios)
model_rebuild(CEJ_ExpedientesActuaciones)
model_rebuild(CEJ_ProcesoScraping)
model_rebuild(CEJ_ProcesoScrapingExpedientes)
