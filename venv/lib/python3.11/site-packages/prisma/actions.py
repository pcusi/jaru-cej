# -*- coding: utf-8 -*-
# code generated by Prisma. DO NOT EDIT.
# pyright: reportUnusedImport=false
# fmt: off
from __future__ import annotations

# global imports for type checking
from builtins import bool as _bool
from builtins import int as _int
from builtins import float as _float
from builtins import str as _str
import sys
import decimal
import datetime
from typing import (
    TYPE_CHECKING,
    Optional,
    Iterable,
    Iterator,
    Sequence,
    Callable,
    ClassVar,
    NoReturn,
    TypeVar,
    Generic,
    Mapping,
    Tuple,
    Union,
    List,
    Dict,
    Type,
    Any,
    Set,
    overload,
    cast,
)
from typing_extensions import TypedDict, Literal


LiteralString = str
# -- template actions.py.jinja --
from typing import TypeVar
import warnings

from . import types, errors, bases
from ._compat import model_parse

if TYPE_CHECKING:
    from .client import Client
    from .bases import _PrismaModel


_PrismaModelT = TypeVar('_PrismaModelT', bound='_PrismaModel')


class CEJ_ExpedientesActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: 'Client', model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.CEJ_Expedientes]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = CEJ_Expedientes.prisma().query_raw(
            'SELECT * FROM CEJ_Expedientes WHERE idExpediente = ?',
            1103527590,
        )
        ```
        """
        return self._client.query_raw(query, *args, model=self._model)

    def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.CEJ_Expedientes
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = CEJ_Expedientes.prisma().query_first(
            'SELECT * FROM CEJ_Expedientes WHERE expedientePJ = ?',
            'dhheabfhf',
        )
        ```
        """
        return self._client.query_first(query, *args, model=self._model)

    def create(
        self,
        data: types.CEJ_ExpedientesCreateInput,
        include: Optional[types.CEJ_ExpedientesInclude] = None
    ) -> _PrismaModelT:
        """Create a new CEJ_Expedientes record.

        Parameters
        ----------
        data
            CEJ_Expedientes record data
        include
            Specifies which relations should be loaded on the returned CEJ_Expedientes model

        Returns
        -------
        prisma.models.CEJ_Expedientes
            The created CEJ_Expedientes record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a CEJ_Expedientes record from just the required fields
        cej_expedientes = CEJ_Expedientes.prisma().create(
            data={
                # data to create a CEJ_Expedientes record
                'expedientePJ': 'ggciceaie',
            },
        )
        ```
        """
        resp = self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    def create_many(
        self,
        data: List[types.CEJ_ExpedientesCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple CEJ_Expedientes records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of CEJ_Expedientes record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = CEJ_Expedientes.prisma().create_many(
            data=[
                {
                    # data to create a CEJ_Expedientes record
                    'expedientePJ': 'bbehjachib',
                },
                {
                    # data to create a CEJ_Expedientes record
                    'expedientePJ': 'cadfabfehe',
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if self._client._active_provider == 'sqlite':
            raise errors.UnsupportedDatabaseError('sqlite', 'create_many()')

        resp = self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    def delete(
        self,
        where: types.CEJ_ExpedientesWhereUniqueInput,
        include: Optional[types.CEJ_ExpedientesInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single CEJ_Expedientes record.

        Parameters
        ----------
        where
            CEJ_Expedientes filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned CEJ_Expedientes model

        Returns
        -------
        prisma.models.CEJ_Expedientes
            The deleted CEJ_Expedientes record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        cej_expedientes = CEJ_Expedientes.prisma().delete(
            where={
                'idExpediente': 368800899,
            },
        )
        ```
        """
        try:
            resp = self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    def find_unique(
        self,
        where: types.CEJ_ExpedientesWhereUniqueInput,
        include: Optional[types.CEJ_ExpedientesInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique CEJ_Expedientes record.

        Parameters
        ----------
        where
            CEJ_Expedientes filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned CEJ_Expedientes model

        Returns
        -------
        prisma.models.CEJ_Expedientes
            The found CEJ_Expedientes record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        cej_expedientes = CEJ_Expedientes.prisma().find_unique(
            where={
                'idExpediente': 1508029952,
            },
        )
        ```
        """
        resp = self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    def find_unique_or_raise(
        self,
        where: types.CEJ_ExpedientesWhereUniqueInput,
        include: Optional[types.CEJ_ExpedientesInclude] = None
    ) -> _PrismaModelT:
        """Find a unique CEJ_Expedientes record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            CEJ_Expedientes filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned CEJ_Expedientes model

        Returns
        -------
        prisma.models.CEJ_Expedientes
            The found CEJ_Expedientes record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        cej_expedientes = CEJ_Expedientes.prisma().find_unique_or_raise(
            where={
                'idExpediente': 486256185,
            },
        )
        ```
        """
        resp = self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.CEJ_ExpedientesWhereInput] = None,
        cursor: Optional[types.CEJ_ExpedientesWhereUniqueInput] = None,
        include: Optional[types.CEJ_ExpedientesInclude] = None,
        order: Optional[Union[types.CEJ_ExpedientesOrderByInput, List[types.CEJ_ExpedientesOrderByInput]]] = None,
        distinct: Optional[List[types.CEJ_ExpedientesScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple CEJ_Expedientes records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of CEJ_Expedientes records returned
        skip
            Ignore the first N results
        where
            CEJ_Expedientes filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned CEJ_Expedientes model
        order
            Order the returned CEJ_Expedientes records by any field
        distinct
            Filter CEJ_Expedientes records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.CEJ_Expedientes]
            The list of all CEJ_Expedientes records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 CEJ_Expedientes records
        cej_expedientes = CEJ_Expedientes.prisma().find_many(take=10)

        # find the first 5 CEJ_Expedientes records ordered by the cuadernos field
        cej_expedientes = CEJ_Expedientes.prisma().find_many(
            take=5,
            order={
                'cuadernos': 'desc',
            },
        )
        ```
        """
        resp = self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.CEJ_ExpedientesWhereInput] = None,
        cursor: Optional[types.CEJ_ExpedientesWhereUniqueInput] = None,
        include: Optional[types.CEJ_ExpedientesInclude] = None,
        order: Optional[Union[types.CEJ_ExpedientesOrderByInput, List[types.CEJ_ExpedientesOrderByInput]]] = None,
        distinct: Optional[List[types.CEJ_ExpedientesScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single CEJ_Expedientes record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            CEJ_Expedientes filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned CEJ_Expedientes model
        order
            Order the returned CEJ_Expedientes records by any field
        distinct
            Filter CEJ_Expedientes records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.CEJ_Expedientes
            The first CEJ_Expedientes record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second CEJ_Expedientes record ordered by the actuaciones field
        cej_expedientes = CEJ_Expedientes.prisma().find_first(
            skip=1,
            order={
                'actuaciones': 'desc',
            },
        )
        ```
        """
        resp = self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.CEJ_ExpedientesWhereInput] = None,
        cursor: Optional[types.CEJ_ExpedientesWhereUniqueInput] = None,
        include: Optional[types.CEJ_ExpedientesInclude] = None,
        order: Optional[Union[types.CEJ_ExpedientesOrderByInput, List[types.CEJ_ExpedientesOrderByInput]]] = None,
        distinct: Optional[List[types.CEJ_ExpedientesScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single CEJ_Expedientes record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            CEJ_Expedientes filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned CEJ_Expedientes model
        order
            Order the returned CEJ_Expedientes records by any field
        distinct
            Filter CEJ_Expedientes records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.CEJ_Expedientes
            The first CEJ_Expedientes record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second CEJ_Expedientes record ordered by the created_at field
        cej_expedientes = CEJ_Expedientes.prisma().find_first_or_raise(
            skip=1,
            order={
                'created_at': 'desc',
            },
        )
        ```
        """
        resp = self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    def update(
        self,
        data: types.CEJ_ExpedientesUpdateInput,
        where: types.CEJ_ExpedientesWhereUniqueInput,
        include: Optional[types.CEJ_ExpedientesInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single CEJ_Expedientes record.

        Parameters
        ----------
        data
            CEJ_Expedientes record data specifying what to update
        where
            CEJ_Expedientes filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned CEJ_Expedientes model

        Returns
        -------
        prisma.models.CEJ_Expedientes
            The updated CEJ_Expedientes record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        cej_expedientes = CEJ_Expedientes.prisma().update(
            where={
                'idExpediente': 1062517886,
            },
            data={
                # data to update the CEJ_Expedientes record to
            },
        )
        ```
        """
        try:
            resp = self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    def upsert(
        self,
        where: types.CEJ_ExpedientesWhereUniqueInput,
        data: types.CEJ_ExpedientesUpsertInput,
        include: Optional[types.CEJ_ExpedientesInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            CEJ_Expedientes filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned CEJ_Expedientes model

        Returns
        -------
        prisma.models.CEJ_Expedientes
            The created or updated CEJ_Expedientes record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        cej_expedientes = CEJ_Expedientes.prisma().upsert(
            where={
                'idExpediente': 267834847,
            },
            data={
                'create': {
                    'idExpediente': 267834847,
                    'expedientePJ': 'cadfabfehe',
                },
                'update': {
                    'expedientePJ': 'cadfabfehe',
                },
            },
        )
        ```
        """
        resp = self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    def update_many(
        self,
        data: types.CEJ_ExpedientesUpdateManyMutationInput,
        where: types.CEJ_ExpedientesWhereInput,
    ) -> int:
        """Update multiple CEJ_Expedientes records

        Parameters
        ----------
        data
            CEJ_Expedientes data to update the selected CEJ_Expedientes records to
        where
            Filter to select the CEJ_Expedientes records to update

        Returns
        -------
        int
            The total number of CEJ_Expedientes records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all CEJ_Expedientes records
        total = CEJ_Expedientes.prisma().update_many(
            data={
                'updated_at': datetime.datetime.utcnow()
            },
            where={}
        )
        ```
        """
        resp = self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.CEJ_ExpedientesWhereInput] = None,
        cursor: Optional[types.CEJ_ExpedientesWhereUniqueInput] = None,
    ) -> int:
        """Count the number of CEJ_Expedientes records present in the database

        Parameters
        ----------
        select
            Select the CEJ_Expedientes fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            CEJ_Expedientes filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.CEJ_ExpedientesCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = CEJ_Expedientes.prisma().count()

        # results: prisma.types.CEJ_ExpedientesCountAggregateOutput
        results = CEJ_Expedientes.prisma().count(
            select={
                '_all': True,
                'juzgado': True,
            },
        )
        ```
        """


    @overload
    def count(
        self,
        select: types.CEJ_ExpedientesCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.CEJ_ExpedientesWhereInput] = None,
        cursor: Optional[types.CEJ_ExpedientesWhereUniqueInput] = None,
    ) -> types.CEJ_ExpedientesCountAggregateOutput:
        ...

    def count(
        self,
        select: Optional[types.CEJ_ExpedientesCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.CEJ_ExpedientesWhereInput] = None,
        cursor: Optional[types.CEJ_ExpedientesWhereUniqueInput] = None,
    ) -> Union[int, types.CEJ_ExpedientesCountAggregateOutput]:
        """Count the number of CEJ_Expedientes records present in the database

        Parameters
        ----------
        select
            Select the CEJ_Expedientes fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            CEJ_Expedientes filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.CEJ_ExpedientesCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = CEJ_Expedientes.prisma().count()

        # results: prisma.types.CEJ_ExpedientesCountAggregateOutput
        results = CEJ_Expedientes.prisma().count(
            select={
                '_all': True,
                'partes': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.CEJ_ExpedientesCountAggregateOutput, resp['data']['result']['_count'])

    def delete_many(
        self,
        where: Optional[types.CEJ_ExpedientesWhereInput] = None
    ) -> int:
        """Delete multiple CEJ_Expedientes records.

        Parameters
        ----------
        where
            Optional CEJ_Expedientes filter to find the records to be deleted

        Returns
        -------
        int
            The total number of CEJ_Expedientes records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all CEJ_Expedientes records
        total = CEJ_Expedientes.prisma().delete_many()
        ```
        """
        resp = self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    def group_by(
        self,
        by: List['types.CEJ_ExpedientesScalarFieldKeys'],
        *,
        where: Optional['types.CEJ_ExpedientesWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.CEJ_ExpedientesAvgAggregateInput'] = None,
        sum: Optional['types.CEJ_ExpedientesSumAggregateInput'] = None,
        min: Optional['types.CEJ_ExpedientesMinAggregateInput'] = None,
        max: Optional['types.CEJ_ExpedientesMaxAggregateInput'] = None,
        having: Optional['types.CEJ_ExpedientesScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.CEJ_ExpedientesCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.CEJ_ExpedientesScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.CEJ_ExpedientesScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.CEJ_ExpedientesGroupByOutput']:
        """Group CEJ_Expedientes records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar CEJ_Expedientes fields to group records by
        where
            CEJ_Expedientes filter to select records
        take
            Limit the maximum number of CEJ_Expedientes records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.CEJ_ExpedientesGroupByOutput]
            A list of dictionaries representing the CEJ_Expedientes record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group CEJ_Expedientes records by activo values
        # and count how many records are in each group
        results = CEJ_Expedientes.prisma().group_by(
            ['activo'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class CEJ_ExpedientesUsuariosActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: 'Client', model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.CEJ_ExpedientesUsuarios]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = CEJ_ExpedientesUsuarios.prisma().query_raw(
            'SELECT * FROM CEJ_ExpedientesUsuarios WHERE id = ?',
            180171308,
        )
        ```
        """
        return self._client.query_raw(query, *args, model=self._model)

    def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.CEJ_ExpedientesUsuarios
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = CEJ_ExpedientesUsuarios.prisma().query_first(
            'SELECT * FROM CEJ_ExpedientesUsuarios WHERE usuario = ?',
            'idghgaicb',
        )
        ```
        """
        return self._client.query_first(query, *args, model=self._model)

    def create(
        self,
        data: types.CEJ_ExpedientesUsuariosCreateInput,
        include: Optional[types.CEJ_ExpedientesUsuariosInclude] = None
    ) -> _PrismaModelT:
        """Create a new CEJ_ExpedientesUsuarios record.

        Parameters
        ----------
        data
            CEJ_ExpedientesUsuarios record data
        include
            Specifies which relations should be loaded on the returned CEJ_ExpedientesUsuarios model

        Returns
        -------
        prisma.models.CEJ_ExpedientesUsuarios
            The created CEJ_ExpedientesUsuarios record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a CEJ_ExpedientesUsuarios record from just the required fields
        cej_expedientesusuarios = CEJ_ExpedientesUsuarios.prisma().create(
            data={
                # data to create a CEJ_ExpedientesUsuarios record
                'usuario': 'fjfddhigg',
            },
        )
        ```
        """
        resp = self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    def create_many(
        self,
        data: List[types.CEJ_ExpedientesUsuariosCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple CEJ_ExpedientesUsuarios records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of CEJ_ExpedientesUsuarios record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = CEJ_ExpedientesUsuarios.prisma().create_many(
            data=[
                {
                    # data to create a CEJ_ExpedientesUsuarios record
                    'usuario': 'hjaecfifb',
                },
                {
                    # data to create a CEJ_ExpedientesUsuarios record
                    'usuario': 'cbbbjbfcii',
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if self._client._active_provider == 'sqlite':
            raise errors.UnsupportedDatabaseError('sqlite', 'create_many()')

        resp = self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    def delete(
        self,
        where: types.CEJ_ExpedientesUsuariosWhereUniqueInput,
        include: Optional[types.CEJ_ExpedientesUsuariosInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single CEJ_ExpedientesUsuarios record.

        Parameters
        ----------
        where
            CEJ_ExpedientesUsuarios filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned CEJ_ExpedientesUsuarios model

        Returns
        -------
        prisma.models.CEJ_ExpedientesUsuarios
            The deleted CEJ_ExpedientesUsuarios record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        cej_expedientesusuarios = CEJ_ExpedientesUsuarios.prisma().delete(
            where={
                'id': 1149758321,
            },
        )
        ```
        """
        try:
            resp = self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    def find_unique(
        self,
        where: types.CEJ_ExpedientesUsuariosWhereUniqueInput,
        include: Optional[types.CEJ_ExpedientesUsuariosInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique CEJ_ExpedientesUsuarios record.

        Parameters
        ----------
        where
            CEJ_ExpedientesUsuarios filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned CEJ_ExpedientesUsuarios model

        Returns
        -------
        prisma.models.CEJ_ExpedientesUsuarios
            The found CEJ_ExpedientesUsuarios record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        cej_expedientesusuarios = CEJ_ExpedientesUsuarios.prisma().find_unique(
            where={
                'id': 1644289366,
            },
        )
        ```
        """
        resp = self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    def find_unique_or_raise(
        self,
        where: types.CEJ_ExpedientesUsuariosWhereUniqueInput,
        include: Optional[types.CEJ_ExpedientesUsuariosInclude] = None
    ) -> _PrismaModelT:
        """Find a unique CEJ_ExpedientesUsuarios record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            CEJ_ExpedientesUsuarios filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned CEJ_ExpedientesUsuarios model

        Returns
        -------
        prisma.models.CEJ_ExpedientesUsuarios
            The found CEJ_ExpedientesUsuarios record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        cej_expedientesusuarios = CEJ_ExpedientesUsuarios.prisma().find_unique_or_raise(
            where={
                'id': 1388290519,
            },
        )
        ```
        """
        resp = self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.CEJ_ExpedientesUsuariosWhereInput] = None,
        cursor: Optional[types.CEJ_ExpedientesUsuariosWhereUniqueInput] = None,
        include: Optional[types.CEJ_ExpedientesUsuariosInclude] = None,
        order: Optional[Union[types.CEJ_ExpedientesUsuariosOrderByInput, List[types.CEJ_ExpedientesUsuariosOrderByInput]]] = None,
        distinct: Optional[List[types.CEJ_ExpedientesUsuariosScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple CEJ_ExpedientesUsuarios records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of CEJ_ExpedientesUsuarios records returned
        skip
            Ignore the first N results
        where
            CEJ_ExpedientesUsuarios filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned CEJ_ExpedientesUsuarios model
        order
            Order the returned CEJ_ExpedientesUsuarios records by any field
        distinct
            Filter CEJ_ExpedientesUsuarios records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.CEJ_ExpedientesUsuarios]
            The list of all CEJ_ExpedientesUsuarios records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 CEJ_ExpedientesUsuarios records
        cej_expedientesusuarios = CEJ_ExpedientesUsuarios.prisma().find_many(take=10)

        # find the first 5 CEJ_ExpedientesUsuarios records ordered by the IdExpediente field
        cej_expedientesusuarios = CEJ_ExpedientesUsuarios.prisma().find_many(
            take=5,
            order={
                'IdExpediente': 'desc',
            },
        )
        ```
        """
        resp = self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.CEJ_ExpedientesUsuariosWhereInput] = None,
        cursor: Optional[types.CEJ_ExpedientesUsuariosWhereUniqueInput] = None,
        include: Optional[types.CEJ_ExpedientesUsuariosInclude] = None,
        order: Optional[Union[types.CEJ_ExpedientesUsuariosOrderByInput, List[types.CEJ_ExpedientesUsuariosOrderByInput]]] = None,
        distinct: Optional[List[types.CEJ_ExpedientesUsuariosScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single CEJ_ExpedientesUsuarios record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            CEJ_ExpedientesUsuarios filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned CEJ_ExpedientesUsuarios model
        order
            Order the returned CEJ_ExpedientesUsuarios records by any field
        distinct
            Filter CEJ_ExpedientesUsuarios records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.CEJ_ExpedientesUsuarios
            The first CEJ_ExpedientesUsuarios record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second CEJ_ExpedientesUsuarios record ordered by the id field
        cej_expedientesusuarios = CEJ_ExpedientesUsuarios.prisma().find_first(
            skip=1,
            order={
                'id': 'desc',
            },
        )
        ```
        """
        resp = self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.CEJ_ExpedientesUsuariosWhereInput] = None,
        cursor: Optional[types.CEJ_ExpedientesUsuariosWhereUniqueInput] = None,
        include: Optional[types.CEJ_ExpedientesUsuariosInclude] = None,
        order: Optional[Union[types.CEJ_ExpedientesUsuariosOrderByInput, List[types.CEJ_ExpedientesUsuariosOrderByInput]]] = None,
        distinct: Optional[List[types.CEJ_ExpedientesUsuariosScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single CEJ_ExpedientesUsuarios record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            CEJ_ExpedientesUsuarios filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned CEJ_ExpedientesUsuarios model
        order
            Order the returned CEJ_ExpedientesUsuarios records by any field
        distinct
            Filter CEJ_ExpedientesUsuarios records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.CEJ_ExpedientesUsuarios
            The first CEJ_ExpedientesUsuarios record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second CEJ_ExpedientesUsuarios record ordered by the usuario field
        cej_expedientesusuarios = CEJ_ExpedientesUsuarios.prisma().find_first_or_raise(
            skip=1,
            order={
                'usuario': 'desc',
            },
        )
        ```
        """
        resp = self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    def update(
        self,
        data: types.CEJ_ExpedientesUsuariosUpdateInput,
        where: types.CEJ_ExpedientesUsuariosWhereUniqueInput,
        include: Optional[types.CEJ_ExpedientesUsuariosInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single CEJ_ExpedientesUsuarios record.

        Parameters
        ----------
        data
            CEJ_ExpedientesUsuarios record data specifying what to update
        where
            CEJ_ExpedientesUsuarios filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned CEJ_ExpedientesUsuarios model

        Returns
        -------
        prisma.models.CEJ_ExpedientesUsuarios
            The updated CEJ_ExpedientesUsuarios record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        cej_expedientesusuarios = CEJ_ExpedientesUsuarios.prisma().update(
            where={
                'id': 1647418052,
            },
            data={
                # data to update the CEJ_ExpedientesUsuarios record to
            },
        )
        ```
        """
        try:
            resp = self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    def upsert(
        self,
        where: types.CEJ_ExpedientesUsuariosWhereUniqueInput,
        data: types.CEJ_ExpedientesUsuariosUpsertInput,
        include: Optional[types.CEJ_ExpedientesUsuariosInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            CEJ_ExpedientesUsuarios filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned CEJ_ExpedientesUsuarios model

        Returns
        -------
        prisma.models.CEJ_ExpedientesUsuarios
            The created or updated CEJ_ExpedientesUsuarios record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        cej_expedientesusuarios = CEJ_ExpedientesUsuarios.prisma().upsert(
            where={
                'id': 1675546029,
            },
            data={
                'create': {
                    'id': 1675546029,
                    'usuario': 'cbbbjbfcii',
                },
                'update': {
                    'usuario': 'cbbbjbfcii',
                },
            },
        )
        ```
        """
        resp = self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    def update_many(
        self,
        data: types.CEJ_ExpedientesUsuariosUpdateManyMutationInput,
        where: types.CEJ_ExpedientesUsuariosWhereInput,
    ) -> int:
        """Update multiple CEJ_ExpedientesUsuarios records

        Parameters
        ----------
        data
            CEJ_ExpedientesUsuarios data to update the selected CEJ_ExpedientesUsuarios records to
        where
            Filter to select the CEJ_ExpedientesUsuarios records to update

        Returns
        -------
        int
            The total number of CEJ_ExpedientesUsuarios records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all CEJ_ExpedientesUsuarios records
        total = CEJ_ExpedientesUsuarios.prisma().update_many(
            data={
                'IdExpediente': 1767274722
            },
            where={}
        )
        ```
        """
        resp = self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.CEJ_ExpedientesUsuariosWhereInput] = None,
        cursor: Optional[types.CEJ_ExpedientesUsuariosWhereUniqueInput] = None,
    ) -> int:
        """Count the number of CEJ_ExpedientesUsuarios records present in the database

        Parameters
        ----------
        select
            Select the CEJ_ExpedientesUsuarios fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            CEJ_ExpedientesUsuarios filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.CEJ_ExpedientesUsuariosCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = CEJ_ExpedientesUsuarios.prisma().count()

        # results: prisma.types.CEJ_ExpedientesUsuariosCountAggregateOutput
        results = CEJ_ExpedientesUsuarios.prisma().count(
            select={
                '_all': True,
                'id': True,
            },
        )
        ```
        """


    @overload
    def count(
        self,
        select: types.CEJ_ExpedientesUsuariosCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.CEJ_ExpedientesUsuariosWhereInput] = None,
        cursor: Optional[types.CEJ_ExpedientesUsuariosWhereUniqueInput] = None,
    ) -> types.CEJ_ExpedientesUsuariosCountAggregateOutput:
        ...

    def count(
        self,
        select: Optional[types.CEJ_ExpedientesUsuariosCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.CEJ_ExpedientesUsuariosWhereInput] = None,
        cursor: Optional[types.CEJ_ExpedientesUsuariosWhereUniqueInput] = None,
    ) -> Union[int, types.CEJ_ExpedientesUsuariosCountAggregateOutput]:
        """Count the number of CEJ_ExpedientesUsuarios records present in the database

        Parameters
        ----------
        select
            Select the CEJ_ExpedientesUsuarios fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            CEJ_ExpedientesUsuarios filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.CEJ_ExpedientesUsuariosCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = CEJ_ExpedientesUsuarios.prisma().count()

        # results: prisma.types.CEJ_ExpedientesUsuariosCountAggregateOutput
        results = CEJ_ExpedientesUsuarios.prisma().count(
            select={
                '_all': True,
                'usuario': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.CEJ_ExpedientesUsuariosCountAggregateOutput, resp['data']['result']['_count'])

    def delete_many(
        self,
        where: Optional[types.CEJ_ExpedientesUsuariosWhereInput] = None
    ) -> int:
        """Delete multiple CEJ_ExpedientesUsuarios records.

        Parameters
        ----------
        where
            Optional CEJ_ExpedientesUsuarios filter to find the records to be deleted

        Returns
        -------
        int
            The total number of CEJ_ExpedientesUsuarios records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all CEJ_ExpedientesUsuarios records
        total = CEJ_ExpedientesUsuarios.prisma().delete_many()
        ```
        """
        resp = self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    def group_by(
        self,
        by: List['types.CEJ_ExpedientesUsuariosScalarFieldKeys'],
        *,
        where: Optional['types.CEJ_ExpedientesUsuariosWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.CEJ_ExpedientesUsuariosAvgAggregateInput'] = None,
        sum: Optional['types.CEJ_ExpedientesUsuariosSumAggregateInput'] = None,
        min: Optional['types.CEJ_ExpedientesUsuariosMinAggregateInput'] = None,
        max: Optional['types.CEJ_ExpedientesUsuariosMaxAggregateInput'] = None,
        having: Optional['types.CEJ_ExpedientesUsuariosScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.CEJ_ExpedientesUsuariosCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.CEJ_ExpedientesUsuariosScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.CEJ_ExpedientesUsuariosScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.CEJ_ExpedientesUsuariosGroupByOutput']:
        """Group CEJ_ExpedientesUsuarios records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar CEJ_ExpedientesUsuarios fields to group records by
        where
            CEJ_ExpedientesUsuarios filter to select records
        take
            Limit the maximum number of CEJ_ExpedientesUsuarios records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.CEJ_ExpedientesUsuariosGroupByOutput]
            A list of dictionaries representing the CEJ_ExpedientesUsuarios record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group CEJ_ExpedientesUsuarios records by IdExpediente values
        # and count how many records are in each group
        results = CEJ_ExpedientesUsuarios.prisma().group_by(
            ['IdExpediente'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class CEJ_ExpedientesActuacionesActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: 'Client', model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.CEJ_ExpedientesActuaciones]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = CEJ_ExpedientesActuaciones.prisma().query_raw(
            'SELECT * FROM CEJ_ExpedientesActuaciones WHERE id = ?',
            326272115,
        )
        ```
        """
        return self._client.query_raw(query, *args, model=self._model)

    def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.CEJ_ExpedientesActuaciones
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = CEJ_ExpedientesActuaciones.prisma().query_first(
            'SELECT * FROM CEJ_ExpedientesActuaciones WHERE idExpediente = ?',
            1343201072,
        )
        ```
        """
        return self._client.query_first(query, *args, model=self._model)

    def create(
        self,
        data: types.CEJ_ExpedientesActuacionesCreateInput,
        include: Optional[types.CEJ_ExpedientesActuacionesInclude] = None
    ) -> _PrismaModelT:
        """Create a new CEJ_ExpedientesActuaciones record.

        Parameters
        ----------
        data
            CEJ_ExpedientesActuaciones record data
        include
            Specifies which relations should be loaded on the returned CEJ_ExpedientesActuaciones model

        Returns
        -------
        prisma.models.CEJ_ExpedientesActuaciones
            The created CEJ_ExpedientesActuaciones record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a CEJ_ExpedientesActuaciones record from just the required fields
        cej_expedientesactuaciones = CEJ_ExpedientesActuaciones.prisma().create(
            data={
                # data to create a CEJ_ExpedientesActuaciones record
                'idActuacion': 'ghfhiafcb',
            },
        )
        ```
        """
        resp = self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    def create_many(
        self,
        data: List[types.CEJ_ExpedientesActuacionesCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple CEJ_ExpedientesActuaciones records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of CEJ_ExpedientesActuaciones record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = CEJ_ExpedientesActuaciones.prisma().create_many(
            data=[
                {
                    # data to create a CEJ_ExpedientesActuaciones record
                    'idActuacion': 'heejgedji',
                },
                {
                    # data to create a CEJ_ExpedientesActuaciones record
                    'idActuacion': 'bjgjgibgbf',
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if self._client._active_provider == 'sqlite':
            raise errors.UnsupportedDatabaseError('sqlite', 'create_many()')

        resp = self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    def delete(
        self,
        where: types.CEJ_ExpedientesActuacionesWhereUniqueInput,
        include: Optional[types.CEJ_ExpedientesActuacionesInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single CEJ_ExpedientesActuaciones record.

        Parameters
        ----------
        where
            CEJ_ExpedientesActuaciones filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned CEJ_ExpedientesActuaciones model

        Returns
        -------
        prisma.models.CEJ_ExpedientesActuaciones
            The deleted CEJ_ExpedientesActuaciones record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        cej_expedientesactuaciones = CEJ_ExpedientesActuaciones.prisma().delete(
            where={
                'id': 1116175964,
            },
        )
        ```
        """
        try:
            resp = self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    def find_unique(
        self,
        where: types.CEJ_ExpedientesActuacionesWhereUniqueInput,
        include: Optional[types.CEJ_ExpedientesActuacionesInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique CEJ_ExpedientesActuaciones record.

        Parameters
        ----------
        where
            CEJ_ExpedientesActuaciones filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned CEJ_ExpedientesActuaciones model

        Returns
        -------
        prisma.models.CEJ_ExpedientesActuaciones
            The found CEJ_ExpedientesActuaciones record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        cej_expedientesactuaciones = CEJ_ExpedientesActuaciones.prisma().find_unique(
            where={
                'id': 861472101,
            },
        )
        ```
        """
        resp = self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    def find_unique_or_raise(
        self,
        where: types.CEJ_ExpedientesActuacionesWhereUniqueInput,
        include: Optional[types.CEJ_ExpedientesActuacionesInclude] = None
    ) -> _PrismaModelT:
        """Find a unique CEJ_ExpedientesActuaciones record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            CEJ_ExpedientesActuaciones filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned CEJ_ExpedientesActuaciones model

        Returns
        -------
        prisma.models.CEJ_ExpedientesActuaciones
            The found CEJ_ExpedientesActuaciones record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        cej_expedientesactuaciones = CEJ_ExpedientesActuaciones.prisma().find_unique_or_raise(
            where={
                'id': 1303003706,
            },
        )
        ```
        """
        resp = self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.CEJ_ExpedientesActuacionesWhereInput] = None,
        cursor: Optional[types.CEJ_ExpedientesActuacionesWhereUniqueInput] = None,
        include: Optional[types.CEJ_ExpedientesActuacionesInclude] = None,
        order: Optional[Union[types.CEJ_ExpedientesActuacionesOrderByInput, List[types.CEJ_ExpedientesActuacionesOrderByInput]]] = None,
        distinct: Optional[List[types.CEJ_ExpedientesActuacionesScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple CEJ_ExpedientesActuaciones records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of CEJ_ExpedientesActuaciones records returned
        skip
            Ignore the first N results
        where
            CEJ_ExpedientesActuaciones filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned CEJ_ExpedientesActuaciones model
        order
            Order the returned CEJ_ExpedientesActuaciones records by any field
        distinct
            Filter CEJ_ExpedientesActuaciones records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.CEJ_ExpedientesActuaciones]
            The list of all CEJ_ExpedientesActuaciones records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 CEJ_ExpedientesActuaciones records
        cej_expedientesactuaciones = CEJ_ExpedientesActuaciones.prisma().find_many(take=10)

        # find the first 5 CEJ_ExpedientesActuaciones records ordered by the idActuacion field
        cej_expedientesactuaciones = CEJ_ExpedientesActuaciones.prisma().find_many(
            take=5,
            order={
                'idActuacion': 'desc',
            },
        )
        ```
        """
        resp = self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.CEJ_ExpedientesActuacionesWhereInput] = None,
        cursor: Optional[types.CEJ_ExpedientesActuacionesWhereUniqueInput] = None,
        include: Optional[types.CEJ_ExpedientesActuacionesInclude] = None,
        order: Optional[Union[types.CEJ_ExpedientesActuacionesOrderByInput, List[types.CEJ_ExpedientesActuacionesOrderByInput]]] = None,
        distinct: Optional[List[types.CEJ_ExpedientesActuacionesScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single CEJ_ExpedientesActuaciones record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            CEJ_ExpedientesActuaciones filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned CEJ_ExpedientesActuaciones model
        order
            Order the returned CEJ_ExpedientesActuaciones records by any field
        distinct
            Filter CEJ_ExpedientesActuaciones records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.CEJ_ExpedientesActuaciones
            The first CEJ_ExpedientesActuaciones record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second CEJ_ExpedientesActuaciones record ordered by the fecha field
        cej_expedientesactuaciones = CEJ_ExpedientesActuaciones.prisma().find_first(
            skip=1,
            order={
                'fecha': 'desc',
            },
        )
        ```
        """
        resp = self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.CEJ_ExpedientesActuacionesWhereInput] = None,
        cursor: Optional[types.CEJ_ExpedientesActuacionesWhereUniqueInput] = None,
        include: Optional[types.CEJ_ExpedientesActuacionesInclude] = None,
        order: Optional[Union[types.CEJ_ExpedientesActuacionesOrderByInput, List[types.CEJ_ExpedientesActuacionesOrderByInput]]] = None,
        distinct: Optional[List[types.CEJ_ExpedientesActuacionesScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single CEJ_ExpedientesActuaciones record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            CEJ_ExpedientesActuaciones filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned CEJ_ExpedientesActuaciones model
        order
            Order the returned CEJ_ExpedientesActuaciones records by any field
        distinct
            Filter CEJ_ExpedientesActuaciones records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.CEJ_ExpedientesActuaciones
            The first CEJ_ExpedientesActuaciones record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second CEJ_ExpedientesActuaciones record ordered by the resolucion field
        cej_expedientesactuaciones = CEJ_ExpedientesActuaciones.prisma().find_first_or_raise(
            skip=1,
            order={
                'resolucion': 'desc',
            },
        )
        ```
        """
        resp = self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    def update(
        self,
        data: types.CEJ_ExpedientesActuacionesUpdateInput,
        where: types.CEJ_ExpedientesActuacionesWhereUniqueInput,
        include: Optional[types.CEJ_ExpedientesActuacionesInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single CEJ_ExpedientesActuaciones record.

        Parameters
        ----------
        data
            CEJ_ExpedientesActuaciones record data specifying what to update
        where
            CEJ_ExpedientesActuaciones filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned CEJ_ExpedientesActuaciones model

        Returns
        -------
        prisma.models.CEJ_ExpedientesActuaciones
            The updated CEJ_ExpedientesActuaciones record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        cej_expedientesactuaciones = CEJ_ExpedientesActuaciones.prisma().update(
            where={
                'id': 1686638315,
            },
            data={
                # data to update the CEJ_ExpedientesActuaciones record to
            },
        )
        ```
        """
        try:
            resp = self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    def upsert(
        self,
        where: types.CEJ_ExpedientesActuacionesWhereUniqueInput,
        data: types.CEJ_ExpedientesActuacionesUpsertInput,
        include: Optional[types.CEJ_ExpedientesActuacionesInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            CEJ_ExpedientesActuaciones filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned CEJ_ExpedientesActuaciones model

        Returns
        -------
        prisma.models.CEJ_ExpedientesActuaciones
            The created or updated CEJ_ExpedientesActuaciones record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        cej_expedientesactuaciones = CEJ_ExpedientesActuaciones.prisma().upsert(
            where={
                'id': 2000430152,
            },
            data={
                'create': {
                    'id': 2000430152,
                    'idActuacion': 'bjgjgibgbf',
                },
                'update': {
                    'idActuacion': 'bjgjgibgbf',
                },
            },
        )
        ```
        """
        resp = self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    def update_many(
        self,
        data: types.CEJ_ExpedientesActuacionesUpdateManyMutationInput,
        where: types.CEJ_ExpedientesActuacionesWhereInput,
    ) -> int:
        """Update multiple CEJ_ExpedientesActuaciones records

        Parameters
        ----------
        data
            CEJ_ExpedientesActuaciones data to update the selected CEJ_ExpedientesActuaciones records to
        where
            Filter to select the CEJ_ExpedientesActuaciones records to update

        Returns
        -------
        int
            The total number of CEJ_ExpedientesActuaciones records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all CEJ_ExpedientesActuaciones records
        total = CEJ_ExpedientesActuaciones.prisma().update_many(
            data={
                'tiponotificacion': 'bigibebcib'
            },
            where={}
        )
        ```
        """
        resp = self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.CEJ_ExpedientesActuacionesWhereInput] = None,
        cursor: Optional[types.CEJ_ExpedientesActuacionesWhereUniqueInput] = None,
    ) -> int:
        """Count the number of CEJ_ExpedientesActuaciones records present in the database

        Parameters
        ----------
        select
            Select the CEJ_ExpedientesActuaciones fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            CEJ_ExpedientesActuaciones filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.CEJ_ExpedientesActuacionesCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = CEJ_ExpedientesActuaciones.prisma().count()

        # results: prisma.types.CEJ_ExpedientesActuacionesCountAggregateOutput
        results = CEJ_ExpedientesActuaciones.prisma().count(
            select={
                '_all': True,
                'acto': True,
            },
        )
        ```
        """


    @overload
    def count(
        self,
        select: types.CEJ_ExpedientesActuacionesCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.CEJ_ExpedientesActuacionesWhereInput] = None,
        cursor: Optional[types.CEJ_ExpedientesActuacionesWhereUniqueInput] = None,
    ) -> types.CEJ_ExpedientesActuacionesCountAggregateOutput:
        ...

    def count(
        self,
        select: Optional[types.CEJ_ExpedientesActuacionesCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.CEJ_ExpedientesActuacionesWhereInput] = None,
        cursor: Optional[types.CEJ_ExpedientesActuacionesWhereUniqueInput] = None,
    ) -> Union[int, types.CEJ_ExpedientesActuacionesCountAggregateOutput]:
        """Count the number of CEJ_ExpedientesActuaciones records present in the database

        Parameters
        ----------
        select
            Select the CEJ_ExpedientesActuaciones fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            CEJ_ExpedientesActuaciones filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.CEJ_ExpedientesActuacionesCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = CEJ_ExpedientesActuaciones.prisma().count()

        # results: prisma.types.CEJ_ExpedientesActuacionesCountAggregateOutput
        results = CEJ_ExpedientesActuaciones.prisma().count(
            select={
                '_all': True,
                'fojas': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.CEJ_ExpedientesActuacionesCountAggregateOutput, resp['data']['result']['_count'])

    def delete_many(
        self,
        where: Optional[types.CEJ_ExpedientesActuacionesWhereInput] = None
    ) -> int:
        """Delete multiple CEJ_ExpedientesActuaciones records.

        Parameters
        ----------
        where
            Optional CEJ_ExpedientesActuaciones filter to find the records to be deleted

        Returns
        -------
        int
            The total number of CEJ_ExpedientesActuaciones records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all CEJ_ExpedientesActuaciones records
        total = CEJ_ExpedientesActuaciones.prisma().delete_many()
        ```
        """
        resp = self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    def group_by(
        self,
        by: List['types.CEJ_ExpedientesActuacionesScalarFieldKeys'],
        *,
        where: Optional['types.CEJ_ExpedientesActuacionesWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.CEJ_ExpedientesActuacionesAvgAggregateInput'] = None,
        sum: Optional['types.CEJ_ExpedientesActuacionesSumAggregateInput'] = None,
        min: Optional['types.CEJ_ExpedientesActuacionesMinAggregateInput'] = None,
        max: Optional['types.CEJ_ExpedientesActuacionesMaxAggregateInput'] = None,
        having: Optional['types.CEJ_ExpedientesActuacionesScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.CEJ_ExpedientesActuacionesCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.CEJ_ExpedientesActuacionesScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.CEJ_ExpedientesActuacionesScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.CEJ_ExpedientesActuacionesGroupByOutput']:
        """Group CEJ_ExpedientesActuaciones records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar CEJ_ExpedientesActuaciones fields to group records by
        where
            CEJ_ExpedientesActuaciones filter to select records
        take
            Limit the maximum number of CEJ_ExpedientesActuaciones records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.CEJ_ExpedientesActuacionesGroupByOutput]
            A list of dictionaries representing the CEJ_ExpedientesActuaciones record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group CEJ_ExpedientesActuaciones records by proveido values
        # and count how many records are in each group
        results = CEJ_ExpedientesActuaciones.prisma().group_by(
            ['proveido'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class CEJ_ProcesoScrapingActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: 'Client', model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.CEJ_ProcesoScraping]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = CEJ_ProcesoScraping.prisma().query_raw(
            'SELECT * FROM CEJ_ProcesoScraping WHERE idProceso = ?',
            1860847622,
        )
        ```
        """
        return self._client.query_raw(query, *args, model=self._model)

    def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.CEJ_ProcesoScraping
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = CEJ_ProcesoScraping.prisma().query_first(
            'SELECT * FROM CEJ_ProcesoScraping WHERE created_at = ?',
            datetime.datetime.utcnow(),
        )
        ```
        """
        return self._client.query_first(query, *args, model=self._model)

    def create(
        self,
        data: types.CEJ_ProcesoScrapingCreateInput,
        include: Optional[types.CEJ_ProcesoScrapingInclude] = None
    ) -> _PrismaModelT:
        """Create a new CEJ_ProcesoScraping record.

        Parameters
        ----------
        data
            CEJ_ProcesoScraping record data
        include
            Specifies which relations should be loaded on the returned CEJ_ProcesoScraping model

        Returns
        -------
        prisma.models.CEJ_ProcesoScraping
            The created CEJ_ProcesoScraping record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a CEJ_ProcesoScraping record from just the required fields
        cej_procesoscraping = CEJ_ProcesoScraping.prisma().create(
            data={
                # data to create a CEJ_ProcesoScraping record
                'portalURL': 'beeifcbebf',
            },
        )
        ```
        """
        resp = self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    def create_many(
        self,
        data: List[types.CEJ_ProcesoScrapingCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple CEJ_ProcesoScraping records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of CEJ_ProcesoScraping record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = CEJ_ProcesoScraping.prisma().create_many(
            data=[
                {
                    # data to create a CEJ_ProcesoScraping record
                    'portalURL': 'bgcigfahea',
                },
                {
                    # data to create a CEJ_ProcesoScraping record
                    'portalURL': 'bcejgaggif',
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if self._client._active_provider == 'sqlite':
            raise errors.UnsupportedDatabaseError('sqlite', 'create_many()')

        resp = self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    def delete(
        self,
        where: types.CEJ_ProcesoScrapingWhereUniqueInput,
        include: Optional[types.CEJ_ProcesoScrapingInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single CEJ_ProcesoScraping record.

        Parameters
        ----------
        where
            CEJ_ProcesoScraping filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned CEJ_ProcesoScraping model

        Returns
        -------
        prisma.models.CEJ_ProcesoScraping
            The deleted CEJ_ProcesoScraping record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        cej_procesoscraping = CEJ_ProcesoScraping.prisma().delete(
            where={
                'idProceso': 835903122,
            },
        )
        ```
        """
        try:
            resp = self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    def find_unique(
        self,
        where: types.CEJ_ProcesoScrapingWhereUniqueInput,
        include: Optional[types.CEJ_ProcesoScrapingInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique CEJ_ProcesoScraping record.

        Parameters
        ----------
        where
            CEJ_ProcesoScraping filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned CEJ_ProcesoScraping model

        Returns
        -------
        prisma.models.CEJ_ProcesoScraping
            The found CEJ_ProcesoScraping record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        cej_procesoscraping = CEJ_ProcesoScraping.prisma().find_unique(
            where={
                'idProceso': 763719779,
            },
        )
        ```
        """
        resp = self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    def find_unique_or_raise(
        self,
        where: types.CEJ_ProcesoScrapingWhereUniqueInput,
        include: Optional[types.CEJ_ProcesoScrapingInclude] = None
    ) -> _PrismaModelT:
        """Find a unique CEJ_ProcesoScraping record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            CEJ_ProcesoScraping filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned CEJ_ProcesoScraping model

        Returns
        -------
        prisma.models.CEJ_ProcesoScraping
            The found CEJ_ProcesoScraping record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        cej_procesoscraping = CEJ_ProcesoScraping.prisma().find_unique_or_raise(
            where={
                'idProceso': 429995104,
            },
        )
        ```
        """
        resp = self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.CEJ_ProcesoScrapingWhereInput] = None,
        cursor: Optional[types.CEJ_ProcesoScrapingWhereUniqueInput] = None,
        include: Optional[types.CEJ_ProcesoScrapingInclude] = None,
        order: Optional[Union[types.CEJ_ProcesoScrapingOrderByInput, List[types.CEJ_ProcesoScrapingOrderByInput]]] = None,
        distinct: Optional[List[types.CEJ_ProcesoScrapingScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple CEJ_ProcesoScraping records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of CEJ_ProcesoScraping records returned
        skip
            Ignore the first N results
        where
            CEJ_ProcesoScraping filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned CEJ_ProcesoScraping model
        order
            Order the returned CEJ_ProcesoScraping records by any field
        distinct
            Filter CEJ_ProcesoScraping records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.CEJ_ProcesoScraping]
            The list of all CEJ_ProcesoScraping records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 CEJ_ProcesoScraping records
        cej_procesoscrapings = CEJ_ProcesoScraping.prisma().find_many(take=10)

        # find the first 5 CEJ_ProcesoScraping records ordered by the portalURL field
        cej_procesoscrapings = CEJ_ProcesoScraping.prisma().find_many(
            take=5,
            order={
                'portalURL': 'desc',
            },
        )
        ```
        """
        resp = self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.CEJ_ProcesoScrapingWhereInput] = None,
        cursor: Optional[types.CEJ_ProcesoScrapingWhereUniqueInput] = None,
        include: Optional[types.CEJ_ProcesoScrapingInclude] = None,
        order: Optional[Union[types.CEJ_ProcesoScrapingOrderByInput, List[types.CEJ_ProcesoScrapingOrderByInput]]] = None,
        distinct: Optional[List[types.CEJ_ProcesoScrapingScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single CEJ_ProcesoScraping record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            CEJ_ProcesoScraping filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned CEJ_ProcesoScraping model
        order
            Order the returned CEJ_ProcesoScraping records by any field
        distinct
            Filter CEJ_ProcesoScraping records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.CEJ_ProcesoScraping
            The first CEJ_ProcesoScraping record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second CEJ_ProcesoScraping record ordered by the concluido field
        cej_procesoscraping = CEJ_ProcesoScraping.prisma().find_first(
            skip=1,
            order={
                'concluido': 'desc',
            },
        )
        ```
        """
        resp = self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.CEJ_ProcesoScrapingWhereInput] = None,
        cursor: Optional[types.CEJ_ProcesoScrapingWhereUniqueInput] = None,
        include: Optional[types.CEJ_ProcesoScrapingInclude] = None,
        order: Optional[Union[types.CEJ_ProcesoScrapingOrderByInput, List[types.CEJ_ProcesoScrapingOrderByInput]]] = None,
        distinct: Optional[List[types.CEJ_ProcesoScrapingScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single CEJ_ProcesoScraping record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            CEJ_ProcesoScraping filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned CEJ_ProcesoScraping model
        order
            Order the returned CEJ_ProcesoScraping records by any field
        distinct
            Filter CEJ_ProcesoScraping records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.CEJ_ProcesoScraping
            The first CEJ_ProcesoScraping record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second CEJ_ProcesoScraping record ordered by the totalExpedientes field
        cej_procesoscraping = CEJ_ProcesoScraping.prisma().find_first_or_raise(
            skip=1,
            order={
                'totalExpedientes': 'desc',
            },
        )
        ```
        """
        resp = self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    def update(
        self,
        data: types.CEJ_ProcesoScrapingUpdateInput,
        where: types.CEJ_ProcesoScrapingWhereUniqueInput,
        include: Optional[types.CEJ_ProcesoScrapingInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single CEJ_ProcesoScraping record.

        Parameters
        ----------
        data
            CEJ_ProcesoScraping record data specifying what to update
        where
            CEJ_ProcesoScraping filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned CEJ_ProcesoScraping model

        Returns
        -------
        prisma.models.CEJ_ProcesoScraping
            The updated CEJ_ProcesoScraping record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        cej_procesoscraping = CEJ_ProcesoScraping.prisma().update(
            where={
                'idProceso': 1775811865,
            },
            data={
                # data to update the CEJ_ProcesoScraping record to
            },
        )
        ```
        """
        try:
            resp = self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    def upsert(
        self,
        where: types.CEJ_ProcesoScrapingWhereUniqueInput,
        data: types.CEJ_ProcesoScrapingUpsertInput,
        include: Optional[types.CEJ_ProcesoScrapingInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            CEJ_ProcesoScraping filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned CEJ_ProcesoScraping model

        Returns
        -------
        prisma.models.CEJ_ProcesoScraping
            The created or updated CEJ_ProcesoScraping record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        cej_procesoscraping = CEJ_ProcesoScraping.prisma().upsert(
            where={
                'idProceso': 893145566,
            },
            data={
                'create': {
                    'idProceso': 893145566,
                    'portalURL': 'bcejgaggif',
                },
                'update': {
                    'portalURL': 'bcejgaggif',
                },
            },
        )
        ```
        """
        resp = self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    def update_many(
        self,
        data: types.CEJ_ProcesoScrapingUpdateManyMutationInput,
        where: types.CEJ_ProcesoScrapingWhereInput,
    ) -> int:
        """Update multiple CEJ_ProcesoScraping records

        Parameters
        ----------
        data
            CEJ_ProcesoScraping data to update the selected CEJ_ProcesoScraping records to
        where
            Filter to select the CEJ_ProcesoScraping records to update

        Returns
        -------
        int
            The total number of CEJ_ProcesoScraping records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all CEJ_ProcesoScraping records
        total = CEJ_ProcesoScraping.prisma().update_many(
            data={
                'updated_at': datetime.datetime.utcnow()
            },
            where={}
        )
        ```
        """
        resp = self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.CEJ_ProcesoScrapingWhereInput] = None,
        cursor: Optional[types.CEJ_ProcesoScrapingWhereUniqueInput] = None,
    ) -> int:
        """Count the number of CEJ_ProcesoScraping records present in the database

        Parameters
        ----------
        select
            Select the CEJ_ProcesoScraping fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            CEJ_ProcesoScraping filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.CEJ_ProcesoScrapingCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = CEJ_ProcesoScraping.prisma().count()

        # results: prisma.types.CEJ_ProcesoScrapingCountAggregateOutput
        results = CEJ_ProcesoScraping.prisma().count(
            select={
                '_all': True,
                'idProceso': True,
            },
        )
        ```
        """


    @overload
    def count(
        self,
        select: types.CEJ_ProcesoScrapingCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.CEJ_ProcesoScrapingWhereInput] = None,
        cursor: Optional[types.CEJ_ProcesoScrapingWhereUniqueInput] = None,
    ) -> types.CEJ_ProcesoScrapingCountAggregateOutput:
        ...

    def count(
        self,
        select: Optional[types.CEJ_ProcesoScrapingCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.CEJ_ProcesoScrapingWhereInput] = None,
        cursor: Optional[types.CEJ_ProcesoScrapingWhereUniqueInput] = None,
    ) -> Union[int, types.CEJ_ProcesoScrapingCountAggregateOutput]:
        """Count the number of CEJ_ProcesoScraping records present in the database

        Parameters
        ----------
        select
            Select the CEJ_ProcesoScraping fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            CEJ_ProcesoScraping filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.CEJ_ProcesoScrapingCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = CEJ_ProcesoScraping.prisma().count()

        # results: prisma.types.CEJ_ProcesoScrapingCountAggregateOutput
        results = CEJ_ProcesoScraping.prisma().count(
            select={
                '_all': True,
                'created_at': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.CEJ_ProcesoScrapingCountAggregateOutput, resp['data']['result']['_count'])

    def delete_many(
        self,
        where: Optional[types.CEJ_ProcesoScrapingWhereInput] = None
    ) -> int:
        """Delete multiple CEJ_ProcesoScraping records.

        Parameters
        ----------
        where
            Optional CEJ_ProcesoScraping filter to find the records to be deleted

        Returns
        -------
        int
            The total number of CEJ_ProcesoScraping records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all CEJ_ProcesoScraping records
        total = CEJ_ProcesoScraping.prisma().delete_many()
        ```
        """
        resp = self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    def group_by(
        self,
        by: List['types.CEJ_ProcesoScrapingScalarFieldKeys'],
        *,
        where: Optional['types.CEJ_ProcesoScrapingWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.CEJ_ProcesoScrapingAvgAggregateInput'] = None,
        sum: Optional['types.CEJ_ProcesoScrapingSumAggregateInput'] = None,
        min: Optional['types.CEJ_ProcesoScrapingMinAggregateInput'] = None,
        max: Optional['types.CEJ_ProcesoScrapingMaxAggregateInput'] = None,
        having: Optional['types.CEJ_ProcesoScrapingScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.CEJ_ProcesoScrapingCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.CEJ_ProcesoScrapingScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.CEJ_ProcesoScrapingScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.CEJ_ProcesoScrapingGroupByOutput']:
        """Group CEJ_ProcesoScraping records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar CEJ_ProcesoScraping fields to group records by
        where
            CEJ_ProcesoScraping filter to select records
        take
            Limit the maximum number of CEJ_ProcesoScraping records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.CEJ_ProcesoScrapingGroupByOutput]
            A list of dictionaries representing the CEJ_ProcesoScraping record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group CEJ_ProcesoScraping records by portalURL values
        # and count how many records are in each group
        results = CEJ_ProcesoScraping.prisma().group_by(
            ['portalURL'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class CEJ_ProcesoScrapingExpedientesActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: 'Client', model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.CEJ_ProcesoScrapingExpedientes]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = CEJ_ProcesoScrapingExpedientes.prisma().query_raw(
            'SELECT * FROM CEJ_ProcesoScrapingExpedientes WHERE id = ?',
            995405759,
        )
        ```
        """
        return self._client.query_raw(query, *args, model=self._model)

    def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.CEJ_ProcesoScrapingExpedientes
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = CEJ_ProcesoScrapingExpedientes.prisma().query_first(
            'SELECT * FROM CEJ_ProcesoScrapingExpedientes WHERE idProceso = ?',
            2102736524,
        )
        ```
        """
        return self._client.query_first(query, *args, model=self._model)

    def create(
        self,
        data: types.CEJ_ProcesoScrapingExpedientesCreateInput,
        include: Optional[types.CEJ_ProcesoScrapingExpedientesInclude] = None
    ) -> _PrismaModelT:
        """Create a new CEJ_ProcesoScrapingExpedientes record.

        Parameters
        ----------
        data
            CEJ_ProcesoScrapingExpedientes record data
        include
            Specifies which relations should be loaded on the returned CEJ_ProcesoScrapingExpedientes model

        Returns
        -------
        prisma.models.CEJ_ProcesoScrapingExpedientes
            The created CEJ_ProcesoScrapingExpedientes record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a CEJ_ProcesoScrapingExpedientes record from just the required fields
        cej_procesoscrapingexpedientes = CEJ_ProcesoScrapingExpedientes.prisma().create(
            data={
                # data to create a CEJ_ProcesoScrapingExpedientes record
                'totalCuadernos': 271520213,
                'totalActuaciones': 456633834,
            },
        )
        ```
        """
        resp = self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    def create_many(
        self,
        data: List[types.CEJ_ProcesoScrapingExpedientesCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple CEJ_ProcesoScrapingExpedientes records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of CEJ_ProcesoScrapingExpedientes record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = CEJ_ProcesoScrapingExpedientes.prisma().create_many(
            data=[
                {
                    # data to create a CEJ_ProcesoScrapingExpedientes record
                    'totalCuadernos': 2058258651,
                    'totalActuaciones': 1583689592,
                },
                {
                    # data to create a CEJ_ProcesoScrapingExpedientes record
                    'totalCuadernos': 878442065,
                    'totalActuaciones': 1675280054,
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if self._client._active_provider == 'sqlite':
            raise errors.UnsupportedDatabaseError('sqlite', 'create_many()')

        resp = self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    def delete(
        self,
        where: types.CEJ_ProcesoScrapingExpedientesWhereUniqueInput,
        include: Optional[types.CEJ_ProcesoScrapingExpedientesInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single CEJ_ProcesoScrapingExpedientes record.

        Parameters
        ----------
        where
            CEJ_ProcesoScrapingExpedientes filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned CEJ_ProcesoScrapingExpedientes model

        Returns
        -------
        prisma.models.CEJ_ProcesoScrapingExpedientes
            The deleted CEJ_ProcesoScrapingExpedientes record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        cej_procesoscrapingexpedientes = CEJ_ProcesoScrapingExpedientes.prisma().delete(
            where={
                'id': 1627576247,
            },
        )
        ```
        """
        try:
            resp = self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    def find_unique(
        self,
        where: types.CEJ_ProcesoScrapingExpedientesWhereUniqueInput,
        include: Optional[types.CEJ_ProcesoScrapingExpedientesInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique CEJ_ProcesoScrapingExpedientes record.

        Parameters
        ----------
        where
            CEJ_ProcesoScrapingExpedientes filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned CEJ_ProcesoScrapingExpedientes model

        Returns
        -------
        prisma.models.CEJ_ProcesoScrapingExpedientes
            The found CEJ_ProcesoScrapingExpedientes record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        cej_procesoscrapingexpedientes = CEJ_ProcesoScrapingExpedientes.prisma().find_unique(
            where={
                'id': 2054802212,
            },
        )
        ```
        """
        resp = self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    def find_unique_or_raise(
        self,
        where: types.CEJ_ProcesoScrapingExpedientesWhereUniqueInput,
        include: Optional[types.CEJ_ProcesoScrapingExpedientesInclude] = None
    ) -> _PrismaModelT:
        """Find a unique CEJ_ProcesoScrapingExpedientes record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            CEJ_ProcesoScrapingExpedientes filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned CEJ_ProcesoScrapingExpedientes model

        Returns
        -------
        prisma.models.CEJ_ProcesoScrapingExpedientes
            The found CEJ_ProcesoScrapingExpedientes record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        cej_procesoscrapingexpedientes = CEJ_ProcesoScrapingExpedientes.prisma().find_unique_or_raise(
            where={
                'id': 60335757,
            },
        )
        ```
        """
        resp = self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.CEJ_ProcesoScrapingExpedientesWhereInput] = None,
        cursor: Optional[types.CEJ_ProcesoScrapingExpedientesWhereUniqueInput] = None,
        include: Optional[types.CEJ_ProcesoScrapingExpedientesInclude] = None,
        order: Optional[Union[types.CEJ_ProcesoScrapingExpedientesOrderByInput, List[types.CEJ_ProcesoScrapingExpedientesOrderByInput]]] = None,
        distinct: Optional[List[types.CEJ_ProcesoScrapingExpedientesScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple CEJ_ProcesoScrapingExpedientes records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of CEJ_ProcesoScrapingExpedientes records returned
        skip
            Ignore the first N results
        where
            CEJ_ProcesoScrapingExpedientes filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned CEJ_ProcesoScrapingExpedientes model
        order
            Order the returned CEJ_ProcesoScrapingExpedientes records by any field
        distinct
            Filter CEJ_ProcesoScrapingExpedientes records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.CEJ_ProcesoScrapingExpedientes]
            The list of all CEJ_ProcesoScrapingExpedientes records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 CEJ_ProcesoScrapingExpedientes records
        cej_procesoscrapingexpedientes = CEJ_ProcesoScrapingExpedientes.prisma().find_many(take=10)

        # find the first 5 CEJ_ProcesoScrapingExpedientes records ordered by the idExpediente field
        cej_procesoscrapingexpedientes = CEJ_ProcesoScrapingExpedientes.prisma().find_many(
            take=5,
            order={
                'idExpediente': 'desc',
            },
        )
        ```
        """
        resp = self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.CEJ_ProcesoScrapingExpedientesWhereInput] = None,
        cursor: Optional[types.CEJ_ProcesoScrapingExpedientesWhereUniqueInput] = None,
        include: Optional[types.CEJ_ProcesoScrapingExpedientesInclude] = None,
        order: Optional[Union[types.CEJ_ProcesoScrapingExpedientesOrderByInput, List[types.CEJ_ProcesoScrapingExpedientesOrderByInput]]] = None,
        distinct: Optional[List[types.CEJ_ProcesoScrapingExpedientesScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single CEJ_ProcesoScrapingExpedientes record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            CEJ_ProcesoScrapingExpedientes filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned CEJ_ProcesoScrapingExpedientes model
        order
            Order the returned CEJ_ProcesoScrapingExpedientes records by any field
        distinct
            Filter CEJ_ProcesoScrapingExpedientes records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.CEJ_ProcesoScrapingExpedientes
            The first CEJ_ProcesoScrapingExpedientes record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second CEJ_ProcesoScrapingExpedientes record ordered by the totalCuadernos field
        cej_procesoscrapingexpedientes = CEJ_ProcesoScrapingExpedientes.prisma().find_first(
            skip=1,
            order={
                'totalCuadernos': 'desc',
            },
        )
        ```
        """
        resp = self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.CEJ_ProcesoScrapingExpedientesWhereInput] = None,
        cursor: Optional[types.CEJ_ProcesoScrapingExpedientesWhereUniqueInput] = None,
        include: Optional[types.CEJ_ProcesoScrapingExpedientesInclude] = None,
        order: Optional[Union[types.CEJ_ProcesoScrapingExpedientesOrderByInput, List[types.CEJ_ProcesoScrapingExpedientesOrderByInput]]] = None,
        distinct: Optional[List[types.CEJ_ProcesoScrapingExpedientesScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single CEJ_ProcesoScrapingExpedientes record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            CEJ_ProcesoScrapingExpedientes filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned CEJ_ProcesoScrapingExpedientes model
        order
            Order the returned CEJ_ProcesoScrapingExpedientes records by any field
        distinct
            Filter CEJ_ProcesoScrapingExpedientes records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.CEJ_ProcesoScrapingExpedientes
            The first CEJ_ProcesoScrapingExpedientes record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second CEJ_ProcesoScrapingExpedientes record ordered by the totalActuaciones field
        cej_procesoscrapingexpedientes = CEJ_ProcesoScrapingExpedientes.prisma().find_first_or_raise(
            skip=1,
            order={
                'totalActuaciones': 'desc',
            },
        )
        ```
        """
        resp = self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    def update(
        self,
        data: types.CEJ_ProcesoScrapingExpedientesUpdateInput,
        where: types.CEJ_ProcesoScrapingExpedientesWhereUniqueInput,
        include: Optional[types.CEJ_ProcesoScrapingExpedientesInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single CEJ_ProcesoScrapingExpedientes record.

        Parameters
        ----------
        data
            CEJ_ProcesoScrapingExpedientes record data specifying what to update
        where
            CEJ_ProcesoScrapingExpedientes filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned CEJ_ProcesoScrapingExpedientes model

        Returns
        -------
        prisma.models.CEJ_ProcesoScrapingExpedientes
            The updated CEJ_ProcesoScrapingExpedientes record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        cej_procesoscrapingexpedientes = CEJ_ProcesoScrapingExpedientes.prisma().update(
            where={
                'id': 684462146,
            },
            data={
                # data to update the CEJ_ProcesoScrapingExpedientes record to
            },
        )
        ```
        """
        try:
            resp = self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    def upsert(
        self,
        where: types.CEJ_ProcesoScrapingExpedientesWhereUniqueInput,
        data: types.CEJ_ProcesoScrapingExpedientesUpsertInput,
        include: Optional[types.CEJ_ProcesoScrapingExpedientesInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            CEJ_ProcesoScrapingExpedientes filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned CEJ_ProcesoScrapingExpedientes model

        Returns
        -------
        prisma.models.CEJ_ProcesoScrapingExpedientes
            The created or updated CEJ_ProcesoScrapingExpedientes record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        cej_procesoscrapingexpedientes = CEJ_ProcesoScrapingExpedientes.prisma().upsert(
            where={
                'id': 1625503827,
            },
            data={
                'create': {
                    'id': 1625503827,
                    'totalCuadernos': 878442065,
                    'totalActuaciones': 1675280054,
                },
                'update': {
                    'totalCuadernos': 878442065,
                    'totalActuaciones': 1675280054,
                },
            },
        )
        ```
        """
        resp = self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    def update_many(
        self,
        data: types.CEJ_ProcesoScrapingExpedientesUpdateManyMutationInput,
        where: types.CEJ_ProcesoScrapingExpedientesWhereInput,
    ) -> int:
        """Update multiple CEJ_ProcesoScrapingExpedientes records

        Parameters
        ----------
        data
            CEJ_ProcesoScrapingExpedientes data to update the selected CEJ_ProcesoScrapingExpedientes records to
        where
            Filter to select the CEJ_ProcesoScrapingExpedientes records to update

        Returns
        -------
        int
            The total number of CEJ_ProcesoScrapingExpedientes records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all CEJ_ProcesoScrapingExpedientes records
        total = CEJ_ProcesoScrapingExpedientes.prisma().update_many(
            data={
                'error': 'fcbichhci'
            },
            where={}
        )
        ```
        """
        resp = self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.CEJ_ProcesoScrapingExpedientesWhereInput] = None,
        cursor: Optional[types.CEJ_ProcesoScrapingExpedientesWhereUniqueInput] = None,
    ) -> int:
        """Count the number of CEJ_ProcesoScrapingExpedientes records present in the database

        Parameters
        ----------
        select
            Select the CEJ_ProcesoScrapingExpedientes fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            CEJ_ProcesoScrapingExpedientes filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.CEJ_ProcesoScrapingExpedientesCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = CEJ_ProcesoScrapingExpedientes.prisma().count()

        # results: prisma.types.CEJ_ProcesoScrapingExpedientesCountAggregateOutput
        results = CEJ_ProcesoScrapingExpedientes.prisma().count(
            select={
                '_all': True,
                'created_at': True,
            },
        )
        ```
        """


    @overload
    def count(
        self,
        select: types.CEJ_ProcesoScrapingExpedientesCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.CEJ_ProcesoScrapingExpedientesWhereInput] = None,
        cursor: Optional[types.CEJ_ProcesoScrapingExpedientesWhereUniqueInput] = None,
    ) -> types.CEJ_ProcesoScrapingExpedientesCountAggregateOutput:
        ...

    def count(
        self,
        select: Optional[types.CEJ_ProcesoScrapingExpedientesCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.CEJ_ProcesoScrapingExpedientesWhereInput] = None,
        cursor: Optional[types.CEJ_ProcesoScrapingExpedientesWhereUniqueInput] = None,
    ) -> Union[int, types.CEJ_ProcesoScrapingExpedientesCountAggregateOutput]:
        """Count the number of CEJ_ProcesoScrapingExpedientes records present in the database

        Parameters
        ----------
        select
            Select the CEJ_ProcesoScrapingExpedientes fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            CEJ_ProcesoScrapingExpedientes filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.CEJ_ProcesoScrapingExpedientesCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = CEJ_ProcesoScrapingExpedientes.prisma().count()

        # results: prisma.types.CEJ_ProcesoScrapingExpedientesCountAggregateOutput
        results = CEJ_ProcesoScrapingExpedientes.prisma().count(
            select={
                '_all': True,
                'id': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.CEJ_ProcesoScrapingExpedientesCountAggregateOutput, resp['data']['result']['_count'])

    def delete_many(
        self,
        where: Optional[types.CEJ_ProcesoScrapingExpedientesWhereInput] = None
    ) -> int:
        """Delete multiple CEJ_ProcesoScrapingExpedientes records.

        Parameters
        ----------
        where
            Optional CEJ_ProcesoScrapingExpedientes filter to find the records to be deleted

        Returns
        -------
        int
            The total number of CEJ_ProcesoScrapingExpedientes records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all CEJ_ProcesoScrapingExpedientes records
        total = CEJ_ProcesoScrapingExpedientes.prisma().delete_many()
        ```
        """
        resp = self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    def group_by(
        self,
        by: List['types.CEJ_ProcesoScrapingExpedientesScalarFieldKeys'],
        *,
        where: Optional['types.CEJ_ProcesoScrapingExpedientesWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.CEJ_ProcesoScrapingExpedientesAvgAggregateInput'] = None,
        sum: Optional['types.CEJ_ProcesoScrapingExpedientesSumAggregateInput'] = None,
        min: Optional['types.CEJ_ProcesoScrapingExpedientesMinAggregateInput'] = None,
        max: Optional['types.CEJ_ProcesoScrapingExpedientesMaxAggregateInput'] = None,
        having: Optional['types.CEJ_ProcesoScrapingExpedientesScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.CEJ_ProcesoScrapingExpedientesCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.CEJ_ProcesoScrapingExpedientesScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.CEJ_ProcesoScrapingExpedientesScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.CEJ_ProcesoScrapingExpedientesGroupByOutput']:
        """Group CEJ_ProcesoScrapingExpedientes records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar CEJ_ProcesoScrapingExpedientes fields to group records by
        where
            CEJ_ProcesoScrapingExpedientes filter to select records
        take
            Limit the maximum number of CEJ_ProcesoScrapingExpedientes records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.CEJ_ProcesoScrapingExpedientesGroupByOutput]
            A list of dictionaries representing the CEJ_ProcesoScrapingExpedientes record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group CEJ_ProcesoScrapingExpedientes records by idProceso values
        # and count how many records are in each group
        results = CEJ_ProcesoScrapingExpedientes.prisma().group_by(
            ['idProceso'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]



def _select_fields(root: str, select: Mapping[str, Any]) -> str:
    """Helper to build a GraphQL selection string

    This is a work around until field selection is added to the query builder.
    """

    return root + ' {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))


from . import models